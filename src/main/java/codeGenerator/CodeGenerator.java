package codeGenerator;

import typechecker.types.*;
import parser.*;
import parser.statements.*;
import parser.expressions.*;

import java.util.*;

public class CodeGenerator {
    // private static ArrayList<String> INCLUDE = new ArrayList<String>(); //holds
    private static ArrayList<String> StructHeaders = new ArrayList<String>();
    private static ArrayList<String> FunctionHeaders = new ArrayList<String>();
    private static ArrayList<String> Classes = new ArrayList<String>();
    private static ArrayList<String> Main = new ArrayList<String>();
    private static Program myProgram;
    private static Map<String, String> varToTypeMap = new HashMap<String, String>();

    public CodeGenerator(Program myProgram) {
        this.myProgram = myProgram;
    }

    public String getCode() throws CodeGeneratorException {
        generateProgramCode();
        String completeCode = "";
        for (int i = 0; i < StructHeaders.size(); i++) {
            completeCode += StructHeaders.get(i);
            completeCode += " ";
        }
        for (int i = 0; i < FunctionHeaders.size(); i++) {
            completeCode += FunctionHeaders.get(i);
            completeCode += " ";
        }
        for (int i = 0; i < Classes.size(); i++) {
            completeCode += Classes.get(i);
            completeCode += " ";
        }
        completeCode += Main.get(0);
        for (int i = 1; i < Main.size(); i++) {
            completeCode += " ";
            completeCode += Main.get(i);
        }
        return completeCode;
    }

    private void generateProgramCode() throws CodeGeneratorException {   
        for (int i = 0; i < myProgram.classDefs.size(); i++) {
            generateClassCode(myProgram.classDefs.get(i));
        }
        generateMainCode();
    }

    private void generateClassCode(ClassDef myClass) throws CodeGeneratorException {
        for(final ClassDef classdef:Program.classDefs){
            classDefinitions.put(classdef.className, classdef);
            if (classdef.parent != "") { // Add parent fields to top of class
                ClassDef parentDef = classDefinitions.get(classdef.parent);
                List<VariableDeclarationStmt> childtemp = classdef.fields;
                classdef.fields = parentDef.fields;
                classdef.fields.addAll(childtemp);
            }
            if(classdef.parent != ""){
                ClassDef parentDef = classDefinitions.get(classdef.parent);
                ArrayList<MethodDef> childtemp = classdef.methods;
                classdef.methods = parentDef.methods;
                classdef.methods.addAll(childtemp);
            }
        }
        //header
        StructHeaders.add("struct");
        StructHeaders.add(myClass.className);
        StructHeaders.add(";");
        Classes.add("struct");
        Classes.add(myClass.className);
        Classes.add("{"); //edit to add parent stuff first?
        for (int i = 0; i < myClass.fields.size(); i++) {// add fields
            generateStatementCode(myClass.fields.get(i), Classes);
        }

        //TO-DO: Deal with parent class
        Classes.add("}");

        // Constructor
        // header
        FunctionHeaders.add(myClass.className);
        FunctionHeaders.add(myClass.className + "_Constructor");
        FunctionHeaders.add("(");
        FunctionHeaders.add(myClass.className);
        FunctionHeaders.add("this");
        for (int i = 0; i < myClass.constructor.parameters.size(); i++) {
            FunctionHeaders.add(",");
            generateStatementCode(myClass.constructor.parameters.get(i), FunctionHeaders);
        }
        generateStatementCode(myClass.constructor.body, FunctionHeaders);

        Classes.add(myClass.className);
        Classes.add(myClass.className + "_Constructor");
        Classes.add("(");
        Classes.add(myClass.className);
        Classes.add("this");
        for (int i = 0; i < myClass.constructor.parameters.size(); i++) {
            Classes.add(",");
            generateStatementCode(myClass.constructor.parameters.get(i), Classes);
        }
        Classes.add(")");
        generateStatementCode(myClass.constructor.body, Classes);
        Classes.remove(Classes.size() - 1);// remove } generated by BlockStmt
        Classes.add("return this ; }" ); //in C constructor needs a valid return





        for (int i = 0; i < myClass.methods.size(); i++) {
            generateMethodDefCode(myClass.methods.get(i), myClass.className);
        }
    }

    private void generateMethodDefCode(MethodDef method, String classname) throws CodeGeneratorException {
        // header
        FunctionHeaders.add(method.type);
        FunctionHeaders.add(classname + "_" + method.name); // classname_methodname handles method name overlap between classes
        FunctionHeaders.add("(");
        FunctionHeaders.add(classname);
        FunctionHeaders.add("this");
        for (int i = 0; i < method.parameters.size(); i++) {
            FunctionHeaders.add(",");
            generateStatementCode(method.parameters.get(i), FunctionHeaders);
        }
        FunctionHeaders.add(")");

        Classes.add(method.type);
        Classes.add(classname + "_" + method.name);
        Classes.add("(");
        Classes.add(classname);
        Classes.add("this");
        for (int i = 0; i < method.parameters.size(); i++) {
            Classes.add(",");
            generateStatementCode(method.parameters.get(i), Classes);
        }
        Classes.add(")");
        generateStatementCode(method.body, Classes);
        // handle returns?
    }

    private void generateMainCode() throws CodeGeneratorException {
        MethodDef mymain = myProgram.entryPoint;
        Main.add("int");
        Main.add("main");
        Main.add("(");
        Main.add(")");
        generateStatementCode(mymain.body, Main);
        // handle returns?
    }

    public static void generateExpressionCode(Expression exp, ArrayList<String> currentList)
            throws CodeGeneratorException {
        if (exp instanceof DivisionExp) {
            DivisionExp div = (DivisionExp) exp;
            currentList.add("(");
            generateExpressionCode(div.exp1, currentList);
            currentList.add("/");
            generateExpressionCode(div.exp2, currentList);
            currentList.add(")");
        } else if (exp instanceof EqualEqualExp) {
            EqualEqualExp equalEqual = (EqualEqualExp) exp;
            currentList.add("(");
            generateExpressionCode(equalEqual.exp1, currentList);
            currentList.add("==");
            generateExpressionCode(equalEqual.exp2, currentList);
            currentList.add(")");
        } else if (exp instanceof GreaterThanExp) {
            GreaterThanExp greaterThan = (GreaterThanExp) exp;
            currentList.add("(");
            generateExpressionCode(greaterThan.exp1, currentList);
            currentList.add(">");
            generateExpressionCode(greaterThan.exp2, currentList);
            currentList.add(")");
        } else if (exp instanceof GreaterThanOrEqualExp) {
            GreaterThanOrEqualExp greaterThanorEqual = (GreaterThanOrEqualExp) exp;
            currentList.add("(");
            generateExpressionCode(greaterThanorEqual.exp1, currentList);
            currentList.add(">=");
            generateExpressionCode(greaterThanorEqual.exp2, currentList);
            currentList.add(")");
        } else if (exp instanceof IntegerExp) {
            IntegerExp integer = (IntegerExp) exp;
            currentList.add("(");
            currentList.add(Integer.toString(integer.value));
            currentList.add(")");
        } else if (exp instanceof LessThanExp) {
            LessThanExp lessThan = (LessThanExp) exp;
            currentList.add("(");
            generateExpressionCode(lessThan.exp1, currentList);
            currentList.add("<");
            generateExpressionCode(lessThan.exp2, currentList);
            currentList.add(")");
        } else if (exp instanceof LessThanOrEqualExp) {
            LessThanOrEqualExp lessThanorEqual = (LessThanOrEqualExp) exp;
            currentList.add("(");
            generateExpressionCode(lessThanorEqual.exp1, currentList);
            currentList.add("<=");
            generateExpressionCode(lessThanorEqual.exp2, currentList);
            currentList.add(")");
        } else if (exp instanceof MethodCallExp) {
            MethodCallExp method = (MethodCallExp) exp;
            String methodname = varToTypeMap.get(method.objectName) + "_" + method.name;
            currentList.add(method.objectName + "." + methodname);
            currentList.add("(");
            List<Expression> paramStmtList = method.parameters;
            for (int i = 0; i < paramStmtList.size(); i++) {
                generateExpressionCode(paramStmtList.get(i), currentList);
                if (i < paramStmtList.size() - 1)// if not the last parameter
                    currentList.add(",");
            }
            currentList.add(")");
        } else if (exp instanceof MinusExp) {
            MinusExp min = (MinusExp) exp;
            currentList.add("(");
            generateExpressionCode(min.exp1, currentList);
            currentList.add("-");
            generateExpressionCode(min.exp2, currentList);
            currentList.add(")");
        } else if (exp instanceof ModulusExp) {
            ModulusExp mod = (ModulusExp) exp;
            currentList.add("(");
            generateExpressionCode(mod.exp1, currentList);
            currentList.add("%");
            generateExpressionCode(mod.exp2, currentList);
            currentList.add(")");
        } else if (exp instanceof MultiplicationExp) {
            MultiplicationExp mult = (MultiplicationExp) exp;
            currentList.add("(");
            generateExpressionCode(mult.exp1, currentList);
            currentList.add("*");
            generateExpressionCode(mult.exp2, currentList);
            currentList.add(")");
        } else if (exp instanceof NewExp) {
            NewExp neww = (NewExp) exp;
            currentList.add(neww.classname + "_Constructor");
            currentList.add("(");
            currentList.add(neww.classname);
            currentList.add(", ");
            List<Expression> paramStmtList = neww.parameters;
            for (int i = 0; i < paramStmtList.size(); i++) {
                generateExpressionCode(paramStmtList.get(i), currentList);
                if (i < paramStmtList.size() - 1)// if not the last parameter
                    currentList.add(",");
            }
            currentList.add(")");
        } else if (exp instanceof ParenthesizedExp) {
            ParenthesizedExp paren = (ParenthesizedExp) exp;
            currentList.add("(");
            generateExpressionCode(paren.body, currentList);
            currentList.add(")");
        } else if (exp instanceof PlusExp) {
            PlusExp plus = (PlusExp) exp;
            currentList.add("(");
            generateExpressionCode(plus.exp1, currentList);
            currentList.add("+");
            generateExpressionCode(plus.exp2, currentList);
            currentList.add(")");
        } else if (exp instanceof StringExp) {
            StringExp string = (StringExp) exp;
            currentList.add("\"" + string.value + "\"");
        } else if (exp instanceof ThisExp) {
            currentList.add("this.");
        } else if (exp instanceof VariableExp) {
            VariableExp var = (VariableExp) exp;
            currentList.add("(");
            currentList.add(var.name);
            currentList.add(")");
        } else {
            throw new CodeGeneratorException("Unknown expression: " + exp.toString());
        }
    }

    public static void generateStatementCode(Statement s, ArrayList<String> currentList) throws CodeGeneratorException {

        if (s instanceof BlockStmt) {
            BlockStmt stmt = (BlockStmt) s;
            currentList.add("{");
            List<Statement> bodyStmtList = stmt.body;
            for (int i = 0; i < bodyStmtList.size(); i++) {
                generateStatementCode(bodyStmtList.get(i), currentList);
            }
            currentList.add("}");
        } else if (s instanceof ForStmt) {
            ForStmt stmt = (ForStmt) s;
            currentList.add("for");
            currentList.add("(");
            generateStatementCode(stmt.initializer, currentList);

            generateExpressionCode(stmt.condition, currentList);
            currentList.add(";");
            generateStatementCode(stmt.incrementor, currentList);
            currentList.remove(currentList.size() - 1);// remove extra semicolon
            currentList.add(")");
            generateStatementCode(stmt.body, currentList);
        } else if (s instanceof IfElseStmt) {
            IfElseStmt stmt = (IfElseStmt) s;
            currentList.add("if");
            currentList.add("(");
            generateExpressionCode(stmt.condition, currentList);
            currentList.add(")");
            generateStatementCode(stmt.trueBranch, currentList);
            currentList.add("else");
            generateStatementCode(stmt.falseBranch, currentList);
        } else if (s instanceof IfStmt) {
            IfStmt stmt = (IfStmt) s;
            currentList.add("if");
            currentList.add("(");
            generateExpressionCode(stmt.condition, currentList);
            currentList.add(")");
            generateStatementCode(stmt.trueBranch, currentList);
        } else if (s instanceof PrintlnStmt) {
            PrintlnStmt stmt = (PrintlnStmt) s;
            currentList.add("printf");
            currentList.add("(");
            generateExpressionCode(stmt.output, currentList);
            currentList.add(")");
            currentList.add(";");
            // currentList.add(generatePrintf(stmt.output, currentList));
            currentList.add("printf(\"\\n\");");
        } else if (s instanceof PrintStmt) {
            PrintStmt stmt = (PrintStmt) s;
            currentList.add("printf");
            currentList.add("(");
            generateExpressionCode(stmt.output, currentList);
            currentList.add(")");
            currentList.add(";");
            // currentList.add(generatePrintf(stmt.output, currentList));
        } else if (s instanceof ReturnStmt) {
            ReturnStmt stmt = (ReturnStmt) s;
            currentList.add("return");
            generateExpressionCode(stmt.value, currentList);
            currentList.add(";");
        } else if (s instanceof ReturnVoidStmt) {
            // Do nothing, no return void in C
        } else if (s instanceof WhileStmt) {
            WhileStmt stmt = (WhileStmt) s;
            currentList.add("while");
            currentList.add("(");
            generateExpressionCode(stmt.condition, currentList);
            currentList.add(")");
            generateStatementCode(stmt.body, currentList);
        } else if (s instanceof VariableDeclarationStmt) {
            VariableDeclarationStmt stmt = (VariableDeclarationStmt) s;
            varToTypeMap.put(stmt.name, stmt.type);
            currentList.add(stmt.type);
            currentList.add(stmt.name);
            if (stmt.value != null) {
                currentList.add("=");
                currentList.add("(");
                currentList.add(varToTypeMap.get(stmt.name)); //int x = (int) 5; is weird but compiles and handles polymorphism for structs
                currentList.add(")");
                generateExpressionCode(stmt.value, currentList);
                currentList.add(";");
            }
        } else if (s instanceof VariableAssignmentStmt) {
            VariableAssignmentStmt stmt = (VariableAssignmentStmt) s;
            currentList.add(stmt.name);
            currentList.add("=");
            currentList.add("(");
            currentList.add(varToTypeMap.get(stmt.name)); //int x = (int) 5; is weird but compiles and handles polymorphism for structs
            currentList.add(")");
            generateExpressionCode(stmt.value, currentList);
            currentList.add(";");
        } else {
            throw new CodeGeneratorException("Unknown statement: " + s.toString());
        }
    }

    // public static String generatePrintf(Expression e, ArrayList<String>
    // currentList) {
    // String output = "printf(\"";
    // // TO-DO
    // output += "\"):";
    // return output;
    // }
    }

